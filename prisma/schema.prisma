// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & WALLET (Aggregate)
// ============================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String?
  role      String   @default("user") // admin, provider, seller, affiliate, conciliator, payment_validator
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  phoneNumber String?
  countryCode String?
  username    String?  @unique

  // Relations
  wallet                  Wallet?
  affiliateProfile        AffiliateProfile?
  providerProfile         ProviderProfile?
  paymentValidatorProfile PaymentValidatorProfile?
  productsAsProvider      Product[]         @relation("ProviderProducts")
  // purchasesAsSeller       Purchase[]        @relation("SellerPurchases")
  // purchasesAsProvider     Purchase[]        @relation("ProviderPurchases")
  affiliationsAsAffiliate Affiliation[]     @relation("AffiliateAffiliations")
  affiliationsAsReferred  Affiliation?      @relation("ReferredAffiliation")
  disputesAsSeller        Dispute[]         @relation("SellerDisputes")
  disputesAsProvider      Dispute[]         @relation("ProviderDisputes")
  disputesAsConciliator   Dispute[]         @relation("ConciliatorDisputes")
  disputeMessages         DisputeMessage[]
  processedWithdrawals    Withdrawal[]      @relation("ProcessedWithdrawals")
  orders                  Order[]
  paymentMethodConfig     PaymentMethodConfig?

  @@map("users")

}

model ProviderProfile {
  id              String    @id @default(cuid())
  userId          String    @unique
  status          String    @default("pending") // pending, approved, rejected, suspended
  applicationNote String?   @db.Text
  rejectionReason String?   @db.Text
  approvedBy      String?   // Admin ID
  approvedAt      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([status])
  @@map("provider_profiles")
}

model PaymentValidatorProfile {
  id              String    @id @default(cuid())
  userId          String    @unique
  status          String    @default("pending") // pending, approved, rejected, suspended
  assignedCountry String?   // ISO country code (PE, MX, BO) - assigned by admin
  applicationNote String?   @db.Text // Notes from validator
  rejectionReason String?   @db.Text // Reason for rejection
  approvedBy      String?   // Admin user ID who approved
  approvedAt      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([status])
  @@index([assignedCountry])
  @@map("payment_validator_profiles")
}

model Wallet {
  id        String   @id @default(cuid())
  userId    String   @unique
  balance   Decimal  @default(0) @db.Decimal(19, 4) // NUNCA Float - Decimal con 4 decimales
  currency  String   @default("USD")
  status    String   @default("active") // active, frozen, closed
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactionsAsSource      Transaction[] @relation("SourceWallet")
  transactionsAsDestination Transaction[] @relation("DestinationWallet")
  recharges                 Recharge[]
  withdrawals               Withdrawal[]

  @@index([userId])
  @@map("wallets")
}

// ============================================
// TRANSACTIONS (Immutable, Audit Trail)
// ============================================

model Transaction {
  id                  String   @id @default(cuid())
  type                String // credit, debit, transfer
  amount              Decimal  @db.Decimal(19, 4)
  sourceWalletId      String?
  destinationWalletId String?
  relatedEntityType   String? // Purchase, Recharge, AffiliateCommission
  relatedEntityId     String?
  description         String
  metadata            Json? // Datos adicionales
  idempotencyKey      String   @unique // Prevenir duplicados
  createdAt           DateTime @default(now())

  // Relations
  sourceWallet      Wallet? @relation("SourceWallet", fields: [sourceWalletId], references: [id])
  destinationWallet Wallet? @relation("DestinationWallet", fields: [destinationWalletId], references: [id])

  @@index([sourceWalletId])
  @@index([destinationWalletId])
  @@index([relatedEntityType, relatedEntityId])
  @@index([createdAt])
  @@map("transactions")
}

model Recharge {
  id                    String    @id @default(cuid())
  walletId              String
  amount                Decimal   @db.Decimal(19, 4)
  paymentMethod         String // credit_card, paypal, bank_transfer, crypto, mock
  paymentGateway        String // stripe, paypal, etc
  externalTransactionId String?   @unique
  status                String    @default("pending") // pending, completed, failed, cancelled
  metadata              Json?
  createdAt             DateTime  @default(now())
  completedAt           DateTime?

  // Relations
  wallet Wallet @relation(fields: [walletId], references: [id])

  @@index([walletId])
  @@index([status])
  @@map("recharges")
}

model Withdrawal {
  id              String    @id @default(cuid())
  walletId        String
  amount          Decimal   @db.Decimal(19, 4)
  paymentMethod   String // paypal, bank_transfer, crypto
  paymentDetails  String // Email, account number, wallet address
  status          String    @default("pending") // pending, approved, rejected, completed
  notes           String?   @db.Text // Provider notes
  rejectionReason String?   @db.Text // Admin rejection reason
  transactionId   String? // ID of the debit transaction when completed
  requestedAt     DateTime  @default(now())
  processedAt     DateTime?
  processedBy     String? // Admin user ID
  completedAt     DateTime?

  // Relations
  wallet          Wallet @relation(fields: [walletId], references: [id])
  processedByUser User?  @relation("ProcessedWithdrawals", fields: [processedBy], references: [id])

  @@index([walletId])
  @@index([status])
  @@index([processedBy])
  @@map("withdrawals")
}

// ============================================
// PRODUCTS (Marketplace Inventory)
// ============================================

// ============================================
// PRODUCTS & INVENTORY (New Structure)
// ============================================

model Product {
  id          String   @id @default(cuid())
  providerId  String
  name        String
  description String?  @db.Text
  category    String // streaming, license, course, ebook, ai
  imageUrl    String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  provider User             @relation("ProviderProducts", fields: [providerId], references: [id])
  variants ProductVariant[]
  
  // Inventory Relations (Reverse lookups)
  inventoryAccounts InventoryAccount[]
  inventoryLicenses InventoryLicense[]
  digitalContents   DigitalContent[]

  @@index([providerId])
  @@index([category])
  @@map("products")
}

model ProductVariant {
  id           String   @id @default(cuid())
  productId    String
  name         String // "1 Mes", "Licencia Vitalicia", "Acceso en Vivo"
  price        Decimal  @db.Decimal(10, 2)
  durationDays Int? // 30, 365, or null
  isRenewable  Boolean  @default(false)
  
  // Relations
  product    Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  orderItems OrderItem[]

  @@index([productId])
  @@map("product_variants")
}

// --- INVENTORY: Streaming & AI ---
model InventoryAccount {
  id           String   @id @default(cuid())
  productId    String
  email        String
  passwordHash String // Encriptada
  totalSlots   Int      @default(1)
  availableSlots Int    @default(1)
  platformType String // netflix, hbo, gpt, perplexity
  expiryDate   DateTime?
  
  // Relations
  product Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  slots   InventorySlot[]

  @@index([productId])
  @@map("inventory_accounts")
}

model InventorySlot {
  id          String   @id @default(cuid())
  accountId   String
  profileName String? // "Perfil 1", "Machetex"
  pinCode     String? // Para Netflix/Disney
  status      String   @default("available") // available, sold, blocked
  
  // Relations
  account   InventoryAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  orderItem OrderItem? // The slot is assigned to an order item

  @@index([accountId])
  @@map("inventory_slots")
}

// --- INVENTORY: Licenses ---
model InventoryLicense {
  id             String   @id @default(cuid())
  productId      String
  licenseKey     String // "XXXX-XXXX-XXXX"
  activationType String // serial, email_invite
  status         String   @default("available") // available, sold
  
  // Relations
  product   Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  orderItem OrderItem?

  @@index([productId])
  @@map("inventory_licenses")
}

// --- INVENTORY: Digital Content (Courses, Ebooks) ---
model DigitalContent {
  id            String    @id @default(cuid())
  productId     String
  contentType   String // live_meet, recorded_iframe, ebook_drive
  resourceUrl   String? // Link de Meet, Iframe Code, o Drive Link
  liveDate      DateTime? // Solo para cursos en vivo
  coverImageUrl String? // Para Ebooks
  
  // Relations
  product   Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  orderItems OrderItem[] // Content can be sold multiple times (unlimited stock usually)

  @@index([productId])
  @@map("digital_content")
}

// ============================================
// ORDERS (Sales)
// ============================================

model Order {
  id          String   @id @default(cuid())
  userId      String // Buyer (Seller or End User)
  totalAmount Decimal  @db.Decimal(10, 2)
  status      String   @default("pending") // pending, paid, failed
  createdAt   DateTime @default(now())
  
  // Relations
  user        User        @relation(fields: [userId], references: [id])
  items       OrderItem[]
  dispute     Dispute?

  @@index([userId])
  @@map("orders")
}

model OrderItem {
  id                String  @id @default(cuid())
  orderId           String
  productVariantId  String
  
  // Polymorphic relations (only one should be set)
  assignedSlotId    String? @unique
  assignedLicenseId String? @unique
  assignedContentId String?
  
  // Relations
  order           Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  variant         ProductVariant    @relation(fields: [productVariantId], references: [id])
  assignedSlot    InventorySlot?    @relation(fields: [assignedSlotId], references: [id])
  assignedLicense InventoryLicense? @relation(fields: [assignedLicenseId], references: [id])
  assignedContent DigitalContent?   @relation(fields: [assignedContentId], references: [id])

  @@index([orderId])
  @@map("order_items")
}

// Legacy Purchase model (kept for reference or migration, but commented out to force refactor)
// model Purchase { ... }

// ============================================
// COMMISSION CONFIG (Admin Settings)
// ============================================

model CommissionConfig {
  id            String   @id @default(cuid())
  type          String // sale, registration
  rate          Decimal  @db.Decimal(5, 2) // 0-100 (ej. 5.50 = 5.5%)
  isActive      Boolean  @default(true)
  effectiveFrom DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([type, isActive])
  @@map("commission_configs")
}

model ReferralApprovalConfig {
  id            String   @id @default(cuid())
  approvalFee   Decimal  @db.Decimal(19, 4) // Monto fijo que se cobra al afiliado al aprobar un referido
  isActive      Boolean  @default(true) // Solo debe haber 1 registro activo
  effectiveFrom DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([isActive])
  @@map("referral_approval_configs")
}

// ============================================
// AFFILIATION (Referral System)
// ============================================

model Affiliation {
  id               String    @id @default(cuid())
  affiliateId      String
  referredUserId   String    @unique // Un usuario solo puede ser referido UNA vez
  referralCode     String
  status           String    @default("active") // active, inactive, suspended
  approvalStatus   String    @default("pending") // pending, approved, rejected - Workflow de aprobación
  approvalFee      Decimal?  @db.Decimal(19, 4) // Monto fijo cobrado al aprobar
  approvedAt       DateTime? // Timestamp de aprobación
  rejectedAt       DateTime? // Timestamp de rechazo
  approvalTransactionId String? // ID de transacción del fee de aprobación
  commissionPaid   Boolean   @default(false)
  commissionAmount Decimal?  @db.Decimal(19, 4) // Snapshot del monto cobrado
  createdAt        DateTime  @default(now())

  // Relations
  affiliate    User @relation("AffiliateAffiliations", fields: [affiliateId], references: [id])
  referredUser User @relation("ReferredAffiliation", fields: [referredUserId], references: [id])

  @@index([affiliateId])
  @@index([referredUserId])
  @@index([referralCode])
  @@index([approvalStatus]) // Para filtrar por estado de aprobación
  @@map("affiliations")
}

model AffiliateProfile {
  id              String    @id @default(cuid())
  userId          String    @unique
  referralCode    String    @unique
  status          String    @default("pending") // pending, approved, active, suspended, rejected
  tier            String    @default("bronze") // bronze, silver, gold, platinum
  totalEarnings   Decimal   @default(0) @db.Decimal(19, 4)
  pendingBalance  Decimal   @default(0) @db.Decimal(19, 4)
  paidBalance     Decimal   @default(0) @db.Decimal(19, 4)
  totalReferrals  Int       @default(0)
  activeReferrals Int       @default(0)
  applicationNote String?   @db.Text // Nota del afiliado al aplicar
  rejectionReason String?   @db.Text // Razón de rechazo
  approvedBy      String? // Admin user ID que aprobó
  approvedAt      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([referralCode])
  @@index([status])
  @@map("affiliate_profiles")
}

// ============================================
// DISPUTES (Conflict Resolution)
// ============================================

model Dispute {
  id                      String    @id @default(cuid())
  orderId                 String    @unique
  sellerId                String // Denormalizado
  providerId              String // Denormalizado
  conciliatorId           String?
  openedBy                String // seller, provider
  reason                  String    @db.Text
  status                  String    @default("open") // open, under_review, resolved, closed
  resolution              String?   @db.Text
  resolutionType          String? // refund_seller, favor_provider, partial_refund, no_action
  partialRefundPercentage Decimal?  @db.Decimal(5, 2) // 0-100, solo para partial_refund
  createdAt               DateTime  @default(now())
  assignedAt              DateTime?
  resolvedAt              DateTime?

  // Relations
  order       Order            @relation(fields: [orderId], references: [id])
  seller      User             @relation("SellerDisputes", fields: [sellerId], references: [id])
  provider    User             @relation("ProviderDisputes", fields: [providerId], references: [id])
  conciliator User?            @relation("ConciliatorDisputes", fields: [conciliatorId], references: [id])
  messages    DisputeMessage[]

  @@index([orderId])
  @@index([status])
  @@index([conciliatorId])
  @@map("disputes")
}

model DisputeMessage {
  id          String   @id @default(cuid())
  disputeId   String
  senderId    String
  message     String   @db.Text
  attachments Json? // URLs de archivos adjuntos
  isInternal  Boolean  @default(false) // Notas internas del conciliator
  createdAt   DateTime @default(now())

  // Relations
  dispute Dispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  sender  User    @relation(fields: [senderId], references: [id])

  @@index([disputeId])
  @@index([createdAt])
  @@map("dispute_messages")
}

// ============================================
// PAYMENT METHOD CONFIG (Per-Country Payment Settings)
// Dynamic payment methods stored as JSON array
// ============================================

model PaymentMethodConfig {
  id          String   @id @default(cuid())
  countryCode String   @unique // PE, BO, MX, etc. - 1 config per country
  validatorId String   @unique // payment_validator user ID
  
  // Dynamic array of payment methods as JSON
  // Structure: [{ id, name, type, color, enabled, phone?, qrImage?, walletAddress?, bankName?, accountNumber?, cci?, holderName?, instructions? }]
  methods     Json     @default("[]")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  validator User @relation(fields: [validatorId], references: [id])

  @@map("payment_method_configs")
}

// ============================================
// AUDIT LOG (Security)
// ============================================

model AuditLog {
  id           String   @id @default(cuid())
  userId       String
  action       String   // VIEW_CREDENTIALS, DECRYPT_ATTEMPT, DECRYPT_FAILED
  resourceType String   // PURCHASE_CREDENTIALS, etc.
  resourceId   String   // The ID of the resource being accessed
  ipAddress    String?
  userAgent    String?
  metadata     String?  // JSON string for additional data
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([resourceType, resourceId])
  @@index([createdAt])
  @@map("audit_logs")
}
