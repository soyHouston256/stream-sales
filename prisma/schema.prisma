// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & WALLET (Aggregate)
// ============================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String?
  role      String   @default("user") // admin, provider, seller, affiliate, conciliator
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  wallet                Wallet?
  productsAsProvider    Product[]     @relation("ProviderProducts")
  purchasesAsSeller     Purchase[]    @relation("SellerPurchases")
  purchasesAsProvider   Purchase[]    @relation("ProviderPurchases")
  affiliationsAsAffiliate  Affiliation[] @relation("AffiliateAffiliations")
  affiliationsAsReferred   Affiliation?  @relation("ReferredAffiliation")
  disputesAsSeller      Dispute[]     @relation("SellerDisputes")
  disputesAsProvider    Dispute[]     @relation("ProviderDisputes")
  disputesAsConciliator Dispute[]     @relation("ConciliatorDisputes")
  disputeMessages       DisputeMessage[]

  @@map("users")
}

model Wallet {
  id        String   @id @default(cuid())
  userId    String   @unique
  balance   Decimal  @default(0) @db.Decimal(19, 4) // NUNCA Float - Decimal con 4 decimales
  currency  String   @default("USD")
  status    String   @default("active") // active, frozen, closed
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactionsAsSource    Transaction[] @relation("SourceWallet")
  transactionsAsDestination Transaction[] @relation("DestinationWallet")
  recharges               Recharge[]

  @@index([userId])
  @@map("wallets")
}

// ============================================
// TRANSACTIONS (Immutable, Audit Trail)
// ============================================

model Transaction {
  id                  String   @id @default(cuid())
  type                String   // credit, debit, transfer
  amount              Decimal  @db.Decimal(19, 4)
  sourceWalletId      String?
  destinationWalletId String?
  relatedEntityType   String?  // Purchase, Recharge, AffiliateCommission
  relatedEntityId     String?
  description         String
  metadata            Json?    // Datos adicionales
  idempotencyKey      String   @unique // Prevenir duplicados
  createdAt           DateTime @default(now())

  // Relations
  sourceWallet      Wallet? @relation("SourceWallet", fields: [sourceWalletId], references: [id])
  destinationWallet Wallet? @relation("DestinationWallet", fields: [destinationWalletId], references: [id])

  @@index([sourceWalletId])
  @@index([destinationWalletId])
  @@index([relatedEntityType, relatedEntityId])
  @@index([createdAt])
  @@map("transactions")
}

model Recharge {
  id                    String    @id @default(cuid())
  walletId              String
  amount                Decimal   @db.Decimal(19, 4)
  paymentMethod         String    // credit_card, paypal, bank_transfer, crypto, mock
  paymentGateway        String    // stripe, paypal, etc
  externalTransactionId String?   @unique
  status                String    @default("pending") // pending, completed, failed, cancelled
  metadata              Json?
  createdAt             DateTime  @default(now())
  completedAt           DateTime?

  // Relations
  wallet Wallet @relation(fields: [walletId], references: [id])

  @@index([walletId])
  @@index([status])
  @@map("recharges")
}

// ============================================
// PRODUCTS (Marketplace Inventory)
// ============================================

model Product {
  id              String    @id @default(cuid())
  providerId      String
  category        String    // netflix, spotify, hbo, disney, prime, youtube, other
  name            String
  description     String    @db.Text
  price           Decimal   @db.Decimal(19, 4)
  accountEmail    String
  accountPassword String    // DEBE estar encriptado
  accountDetails  Json?     // Datos adicionales (plan, perfil, etc)
  status          String    @default("available") // available, reserved, sold
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  soldAt          DateTime?

  // Relations
  provider User      @relation("ProviderProducts", fields: [providerId], references: [id])
  purchase Purchase?

  @@index([providerId])
  @@index([status])
  @@index([category])
  @@map("products")
}

// ============================================
// PURCHASES (Core Business Transaction)
// ============================================

model Purchase {
  id               String    @id @default(cuid())
  sellerId         String
  productId        String    @unique // Un producto solo se vende UNA vez
  providerId       String    // Denormalizado para queries
  amount           Decimal   @db.Decimal(19, 4)
  providerEarnings Decimal   @db.Decimal(19, 4) // amount - commission
  adminCommission  Decimal   @db.Decimal(19, 4)
  commissionRate   Decimal   @db.Decimal(5, 2) // Snapshot del % en el momento (ej. 5.50)
  status           String    @default("pending") // pending, completed, failed, refunded
  transactionIds   Json?     // Array de IDs de transacciones generadas
  createdAt        DateTime  @default(now())
  completedAt      DateTime?
  refundedAt       DateTime?

  // Relations
  seller   User     @relation("SellerPurchases", fields: [sellerId], references: [id])
  provider User     @relation("ProviderPurchases", fields: [providerId], references: [id])
  product  Product  @relation(fields: [productId], references: [id])
  dispute  Dispute?

  @@index([sellerId])
  @@index([providerId])
  @@index([status])
  @@index([createdAt])
  @@map("purchases")
}

// ============================================
// COMMISSION CONFIG (Admin Settings)
// ============================================

model CommissionConfig {
  id            String   @id @default(cuid())
  type          String   // sale, registration
  rate          Decimal  @db.Decimal(5, 2) // 0-100 (ej. 5.50 = 5.5%)
  isActive      Boolean  @default(true)
  effectiveFrom DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([type, isActive])
  @@map("commission_configs")
}

// ============================================
// AFFILIATION (Referral System)
// ============================================

model Affiliation {
  id              String    @id @default(cuid())
  affiliateId     String
  referredUserId  String    @unique // Un usuario solo puede ser referido UNA vez
  referralCode    String
  status          String    @default("active") // active, inactive, suspended
  commissionPaid  Boolean   @default(false)
  commissionAmount Decimal? @db.Decimal(19, 4) // Snapshot del monto cobrado
  createdAt       DateTime  @default(now())

  // Relations
  affiliate     User @relation("AffiliateAffiliations", fields: [affiliateId], references: [id])
  referredUser  User @relation("ReferredAffiliation", fields: [referredUserId], references: [id])

  @@index([affiliateId])
  @@index([referredUserId])
  @@index([referralCode])
  @@map("affiliations")
}

// ============================================
// DISPUTES (Conflict Resolution)
// ============================================

model Dispute {
  id             String    @id @default(cuid())
  purchaseId     String
  sellerId       String    // Denormalizado
  providerId     String    // Denormalizado
  conciliatorId  String?
  openedBy       String    // seller, provider
  reason         String    @db.Text
  status         String    @default("open") // open, under_review, resolved, closed
  resolution     String?   @db.Text
  resolutionType String?   // refund_seller, favor_provider, partial_refund, no_action
  createdAt      DateTime  @default(now())
  assignedAt     DateTime?
  resolvedAt     DateTime?

  // Relations
  purchase    Purchase         @relation(fields: [purchaseId], references: [id])
  seller      User             @relation("SellerDisputes", fields: [sellerId], references: [id])
  provider    User             @relation("ProviderDisputes", fields: [providerId], references: [id])
  conciliator User?            @relation("ConciliatorDisputes", fields: [conciliatorId], references: [id])
  messages    DisputeMessage[]

  @@index([purchaseId])
  @@index([status])
  @@index([conciliatorId])
  @@map("disputes")
}

model DisputeMessage {
  id          String   @id @default(cuid())
  disputeId   String
  senderId    String
  message     String   @db.Text
  attachments Json?    // URLs de archivos adjuntos
  isInternal  Boolean  @default(false) // Notas internas del conciliator
  createdAt   DateTime @default(now())

  // Relations
  dispute Dispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  sender  User    @relation(fields: [senderId], references: [id])

  @@index([disputeId])
  @@index([createdAt])
  @@map("dispute_messages")
}
